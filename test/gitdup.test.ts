import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { gitdup } from '../src/index';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import { execFile, type ExecException } from 'node:child_process';
const TMP_ROOT = path.join(process.cwd(), '.tmp', 'gitdup');

function exec(
  cmd: string,
  args: string[],
  cwd: string
): Promise<{ stdout: string; stderr: string; code: number }> {
  return new Promise((resolve) => {
    execFile(cmd, args, { cwd }, (error, stdout, stderr) => {
      const err = error as ExecException | null;
      const code = err
        ? typeof err.code === 'number'
          ? (err.code as number)
          : 1
        : 0;
      resolve({ stdout: String(stdout), stderr: String(stderr), code });
    });
  });
}

async function ensureGitAvailable() {
  const res = await exec('git', ['--version'], process.cwd());
  if (res.code !== 0) throw new Error('git not available');
}

async function mkTempDir(prefix = 'gitdup-test-'): Promise<string> {
  await fs.mkdir(TMP_ROOT, { recursive: true });
  const dir = await fs.mkdtemp(path.join(TMP_ROOT, prefix));
  return dir;
}

async function initRepo(dir: string): Promise<void> {
  const run = async (args: string[]) => {
    const { code, stderr } = await exec('git', args, dir);
    if (code !== 0) throw new Error(`git ${args.join(' ')} failed: ${stderr}`);
  };
  await run(['init']);
  await run(['config', 'user.email', 'test@example.com']);
  await run(['config', 'user.name', 'Test User']);
  await fs.writeFile(path.join(dir, 'README.md'), '# Test\n');
  await run(['add', 'README.md']);
  await run(['commit', '-m', 'chore: initial commit']);
}

describe('gitdup', () => {
  beforeAll(async () => {
    await ensureGitAvailable();
  });
  afterAll(async () => {
    await fs.rm(TMP_ROOT, { recursive: true, force: true });
  });

  it('duplicates into default -dup path and resets tracked changes', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    const trackedFile = path.join(repo, 'README.md');
    // modify tracked file (uncommitted change)
    await fs.writeFile(trackedFile, '# Modified\n');
    // add untracked file
    await fs.writeFile(path.join(repo, 'untracked.txt'), 'untracked');
    // add .gitignore to ignore .env
    await fs.writeFile(path.join(repo, '.gitignore'), '.env\n');
    await fs.writeFile(path.join(repo, '.env'), 'MY_SECRET=1');

    const prev = process.cwd();
    try {
      process.chdir(repo);
      const res = await gitdup();
      // default dest ends with -dup
      expect(path.basename(res.dest)).toMatch(/-dup(\b|-.+)/);
      const duplicatedReadme = await fs.readFile(
        path.join(res.dest, 'README.md'),
        'utf8'
      );
      // should be reset to committed content
      expect(duplicatedReadme).toBe('# Test\n');

      // untracked file should exist
      await expect(
        fs.readFile(path.join(res.dest, 'untracked.txt'), 'utf8')
      ).resolves.toBe('untracked');
      // ignored .env should exist
      await expect(
        fs.readFile(path.join(res.dest, '.env'), 'utf8')
      ).resolves.toContain('MY_SECRET');
    } finally {
      process.chdir(prev);
    }
  });

  it('uses incremented default name if <cwd>-dup exists', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    const base = path.basename(repo);
    const dup0 = path.join(path.dirname(repo), `${base}-dup`);
    // create an existing dup folder to force increment
    await fs.mkdir(dup0, { recursive: true });

    const prev = process.cwd();
    try {
      process.chdir(repo);
      const res = await gitdup();
      expect(path.basename(res.dest)).toMatch(/-dup-\d+/);
      expect(res.dest).not.toBe(dup0);
    } finally {
      process.chdir(prev);
    }
  });

  it('errors if destination exists and is non-empty', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    const nonEmpty = await mkTempDir();
    await fs.writeFile(path.join(nonEmpty, 'file.txt'), 'x');

    const prev = process.cwd();
    try {
      process.chdir(repo);
      await expect(gitdup({ dest: nonEmpty })).rejects.toThrow(/must be empty/);
    } finally {
      process.chdir(prev);
    }
  });

  it('errors if destination exists and is a file', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    const fileDest = path.join(TMP_ROOT, 'file-dest');
    await fs.writeFile(fileDest, 'x');

    const prev = process.cwd();
    try {
      process.chdir(repo);
      await expect(gitdup({ dest: fileDest })).rejects.toThrow(
        /not a directory/
      );
    } finally {
      process.chdir(prev);
    }
  });

  it('allows destination that exists but is empty', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    const empty = await mkTempDir();
    // empty dir: remove the autogenerated random subdir content to make it empty
    // mkdtemp creates the directory; ensure it is empty by deleting and recreating
    const entries = await fs.readdir(empty);
    for (const e of entries) {
      await fs.rm(path.join(empty, e), { recursive: true, force: true });
    }

    const prev = process.cwd();
    try {
      process.chdir(repo);
      const res = await gitdup({ dest: empty });
      expect(res.dest).toBe(empty);
      await expect(fs.stat(path.join(empty, '.git'))).resolves.toBeTruthy();
    } finally {
      process.chdir(prev);
    }
  });

  it('creates destination if it does not exist', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    const desired = path.join(TMP_ROOT, 'new-dest');
    await fs.rm(desired, { recursive: true, force: true });
    const prev = process.cwd();
    try {
      process.chdir(repo);
      const res = await gitdup({ dest: desired });
      expect(res.dest).toBe(desired);
      await expect(fs.stat(path.join(desired, '.git'))).resolves.toBeTruthy();
    } finally {
      process.chdir(prev);
    }
  });

  it('option --clean removes untracked but keeps ignored files', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    await fs.writeFile(path.join(repo, '.gitignore'), '.env\n');
    await fs.writeFile(path.join(repo, '.env'), 'SECRET=1');
    await fs.writeFile(path.join(repo, 'scratch.log'), 'temp'); // untracked, not ignored

    const prev = process.cwd();
    try {
      process.chdir(repo);
      const target = path.join(repo, '..', path.basename(repo) + '-dup-clean');
      const res = await gitdup({ dest: target, clean: true });
      // untracked non-ignored should be gone
      await expect(
        fs.stat(path.join(res.dest, 'scratch.log'))
      ).rejects.toBeTruthy();
      // ignored should remain
      await expect(
        fs.readFile(path.join(res.dest, '.env'), 'utf8')
      ).resolves.toContain('SECRET');
    } finally {
      process.chdir(prev);
    }
  });

  it('can checkout an existing local branch without remotes', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    // create new branch in source repo
    const run = async (args: string[]) => {
      const { code, stderr } = await exec('git', args, repo);
      if (code !== 0) throw new Error(stderr);
    };
    await run(['checkout', '-b', 'feature/test']);
    await fs.writeFile(path.join(repo, 'new.txt'), 'branch file');
    await run(['add', 'new.txt']);
    await run(['commit', '-m', 'feat: add new file']);

    const prev = process.cwd();
    try {
      process.chdir(repo);
      const res = await gitdup({ branch: 'feature/test' });
      // The branch should be checked out and file present
      const content = await fs.readFile(path.join(res.dest, 'new.txt'), 'utf8');
      expect(content).toBe('branch file');
    } finally {
      process.chdir(prev);
    }
  });

  it('rejects destination inside current directory', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    const inner = path.join(repo, 'inner-dest');
    const prev = process.cwd();
    try {
      process.chdir(repo);
      await expect(gitdup({ dest: inner })).rejects.toThrow(
        /must not be inside/
      );
    } finally {
      process.chdir(prev);
    }
  });

  it('rejects when dest equals current directory', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    const prev = process.cwd();
    try {
      process.chdir(repo);
      await expect(gitdup({ dest: repo })).rejects.toThrow(
        /Destination is the same/
      );
    } finally {
      process.chdir(prev);
    }
  });

  it('fails PR checkout when no remote configured', async () => {
    const repo = await mkTempDir();
    await initRepo(repo);
    const prev = process.cwd();
    try {
      process.chdir(repo);
      await expect(gitdup({ pr: 123 })).rejects.toThrow(/git fetch/);
    } finally {
      process.chdir(prev);
    }
  });

  it('fetches and checks out a PR ref from a local bare remote', async () => {
    // Setup a bare remote that mimics GitHub PR refs
    const bare = await mkTempDir('remote-bare-');
    // init bare repo
    let r = await exec('git', ['init', '--bare'], bare);
    if (r.code !== 0) throw new Error(r.stderr);

    // Create a working repo to push commits and a PR ref into the bare remote
    const workParent = await mkTempDir('remote-work-');
    const work = path.join(workParent, 'work');
    r = await exec('git', ['clone', bare, work], process.cwd());
    if (r.code !== 0) throw new Error(r.stderr);
    const runWork = async (args: string[]) => {
      const { code, stderr } = await exec('git', args, work);
      if (code !== 0) throw new Error(stderr);
    };
    await runWork(['config', 'user.email', 'test@example.com']);
    await runWork(['config', 'user.name', 'Test User']);
    await fs.writeFile(path.join(work, 'pr.txt'), 'hello pr');
    await runWork(['add', 'pr.txt']);
    await runWork(['commit', '-m', 'feat: add pr file']);
    // Push commit to a PR ref on the bare remote
    await runWork(['push', 'origin', 'HEAD:refs/pull/123/head']);

    // Create our source repo and point its remote to the bare remote
    const repo = await mkTempDir('source-');
    await initRepo(repo);
    const res = await exec('git', ['remote', 'add', 'origin', bare], repo);
    if (res.code !== 0) throw new Error(res.stderr);

    const prev = process.cwd();
    try {
      process.chdir(repo);
      const dup = await gitdup({ pr: 123 });
      // Ensure the PR branch was checked out and file is present
      const content = await fs.readFile(path.join(dup.dest, 'pr.txt'), 'utf8');
      expect(content).toBe('hello pr');
    } finally {
      process.chdir(prev);
    }
  });

  it('errors when not inside a git repo', async () => {
    const tmp = await mkTempDir();
    const prev = process.cwd();
    try {
      process.chdir(tmp);
      await expect(gitdup()).rejects.toThrow(/Not a git repository/);
    } finally {
      process.chdir(prev);
    }
  });
});
